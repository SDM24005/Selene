<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Selene Mobile Friendly</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #000a4b;
    font-family: sans-serif;
    color: white;
    user-select: none;
    touch-action: none; /* Impedisce il comportamento di default del browser come lo zoom */
  }
  #canvas {
    display: block;
    cursor: grab;
    width: 100vw;
    height: 100vh;
  }
  #canvas:active {
    cursor: grabbing;
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let width, height;

  const physics = {
    repulsion: 18000,
    friction: 0.7,
    gravity: 0.025,
    dampening: 0.4,
    repulsionDistanceSq: 300 * 300
  };
  
  // --- IMPOSTAZIONI DI OTTIMIZZAZIONE ---
  const ZOOM_LOD_THRESHOLD = 1.0; 
  const VISIBILITY_MARGIN = 300; 

  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let nodes = [];
  
  let isPanning = false;
  let panStart = {x:0, y:0};
  let isDraggingNode = false;
  let dragNode = null;
  let hasDragged = false;
  let dragStartMouse = {x:0, y:0};

  let time = 0;
  const imageCache = new Map();

  // --- VARIABILI PER LA GESTIONE TOUCH ---
  let touchCache = {}; // Per memorizzare i punti di contatto
  let touchDistance = null; // Distanza tra due dita per lo zoom

  class Node {
    constructor(id, link, x, y, maxSize, imageName, imageNameLow) {
      this.id = id;
      this.link = link;
      this.x = x; this.y = y;
      this.vx = 0; this.vy = 0;
      this.maxSize = maxSize || 96;
      this.width = this.height = this.maxSize;
      
      this.imageName = imageName;
      this.imageNameLow = imageNameLow; 

      this.wigglePhaseX = Math.random() * Math.PI * 2;
      this.wigglePhaseY = Math.random() * Math.PI * 2;
      this.wiggleFreqX = 0.0003 + Math.random() * 0.0005;
      this.wiggleFreqY = 0.0003 + Math.random() * 0.0005;

      this.dragOffsetX = 0;
      this.dragOffsetY = 0;
      this.isVisible = false;
      
      this.imgHigh = null;      
      this.imgLow = null;       
      this.imgToDraw = null;    
    }
    
    computeSize() {
      const img = this.imgHigh || this.imgLow; 
      if (!img || !img.width || !img.height) return;

      if (img.width > img.height) {
          this.width = this.maxSize;
          this.height = img.height * (this.maxSize / img.width);
      } else {
          this.height = this.maxSize;
          this.width = img.width * (this.maxSize / img.height);
      }
    }
    
    containsPoint(px, py) {
      const halfWidth = this.width / 2;
      const halfHeight = this.height / 2;
      return px >= this.x - halfWidth && px <= this.x + halfWidth &&
             py >= this.y - halfHeight && py <= this.y + halfHeight;
    }
    
    applyForce(fx, fy) {
      this.vx += fx;
      this.vy += fy;
    }
    
    update() {
      if (this !== dragNode) {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= physics.friction;
        this.vy *= physics.friction;
      }
    }
  }

  function applyForces() {
    for (let i = 0; i < nodes.length; i++) {
      const nodeA = nodes[i];
      if (!nodeA.isVisible) continue; 
      
      for (let j = i + 1; j < nodes.length; j++) {
        const nodeB = nodes[j];
        if (!nodeB.isVisible) continue; 

        const dx = nodeB.x - nodeA.x;
        const dy = nodeB.y - nodeA.y;
        const distanceSq = dx * dx + dy * dy;
        
        if (distanceSq < physics.repulsionDistanceSq && distanceSq > 1) {
          const force = physics.repulsion / distanceSq;
          const angle = Math.atan2(dy, dx);
          const fx = -force * Math.cos(angle);
          const fy = -force * Math.sin(angle);
          nodeA.applyForce(fx * physics.dampening, fy * physics.dampening);
          nodeB.applyForce(-fx * physics.dampening, -fy * physics.dampening);
        }
      }
    }

    for (const node of nodes) {
      if (!node.isVisible) continue; 

      const dx = -node.x;
      const dy = -node.y;
      node.applyForce(dx * physics.gravity * physics.dampening, dy * physics.gravity * physics.dampening);
      
      const amplitude = 0.4;
      if (node !== dragNode) {
        const wiggleX = amplitude * Math.sin(time * node.wiggleFreqX + node.wigglePhaseX);
        const wiggleY = amplitude * Math.cos(time * node.wiggleFreqY + node.wigglePhaseY);
        node.applyForce(wiggleX, wiggleY);
      }
    }
    time++;
  }
  
  function manageImageLoading() {
    nodes.forEach(node => {
      if (!node.isVisible) {
        node.imgToDraw = null; 
        return;
      }

      const wantsHighRes = zoom > ZOOM_LOD_THRESHOLD;

      if (wantsHighRes) {
        if (node.imgHigh) {
          node.imgToDraw = node.imgHigh;
        } else {
          loadImage(node, 'high');
          node.imgToDraw = node.imgLow; 
        }
      } else {
        if (node.imgLow) {
          node.imgToDraw = node.imgLow;
        } else {
          loadImage(node, 'low');
          node.imgToDraw = node.imgHigh; 
        }
      }
    });
  }

  function loadImage(node, quality) {
    const isHigh = quality === 'high';
    const imageName = isHigh ? node.imageName : node.imageNameLow;
    if (!imageName) return;

    if ((isHigh && node.imgHigh) || (!isHigh && node.imgLow)) return; 
    
    let cachedImg = imageCache.get(imageName);
    if (cachedImg) {
      if (cachedImg.complete) {
        if (isHigh) { node.imgHigh = cachedImg; node.computeSize(); }
        else { node.imgLow = cachedImg; }
      }
      return;
    }

    const img = new Image();
    img.src = 'img/' + imageName;
    imageCache.set(imageName, img); 

    img.onload = () => {
      if (isHigh) {
        node.imgHigh = img;
        node.computeSize();
      } else {
        node.imgLow = img;
      }
    };
    img.onerror = () => console.warn('Immagine non trovata:', img.src);
  }

  function loadAssetsFromJSON(url) {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!Array.isArray(data)) return console.error('JSON non Ã¨ un array');
        
        const gridSpacing = 160;
        const gridCols = Math.ceil(Math.sqrt(data.length));

        data.forEach((item, i) => {
          const col = i % gridCols;
          const row = Math.floor(i / gridCols);
          const x = col * gridSpacing - (gridCols * gridSpacing) / 2;
          const y = row * gridSpacing - (gridCols * gridSpacing) / 2;
          const node = new Node(i, item.link, x, y, 96, item.name, item.name_low);
          nodes.push(node);
        });

        setupAndStart();
      })
      .catch(err => console.error('Errore caricamento JSON:', err));
  }

  function setupAndStart() {
    resizeCanvas();
    autoZoomAndCenter();
    animate();
  }

  function draw() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#000a4b';
    ctx.fillRect(0, 0, width, height);

    ctx.translate(width / 2, height / 2);
    ctx.scale(zoom, zoom);
    ctx.translate(offsetX, offsetY);

    updateVisibility();
    manageImageLoading(); 

    for (const node of nodes) {
      if (!node.isVisible || !node.imgToDraw) continue;

      const drawWidth = node.width;
      const drawHeight = node.height;
      ctx.drawImage(node.imgToDraw, node.x - drawWidth / 2, node.y - drawHeight / 2, drawWidth, drawHeight);
    }
  }

  function animate() {
    applyForces();
    for (const node of nodes) {
      node.update();
    }
    draw();
    requestAnimationFrame(animate);
  }

  function updateVisibility() {
    const left = -offsetX - width / 2 / zoom - VISIBILITY_MARGIN;
    const right = -offsetX + width / 2 / zoom + VISIBILITY_MARGIN;
    const top = -offsetY - height / 2 / zoom - VISIBILITY_MARGIN;
    const bottom = -offsetY + height / 2 / zoom + VISIBILITY_MARGIN;

    nodes.forEach(node => {
      const nodeLeft = node.x - node.width / 2;
      const nodeRight = node.x + node.width / 2;
      const nodeTop = node.y - node.height / 2;
      const nodeBottom = node.y + node.height / 2;
      node.isVisible = !(nodeRight < left || nodeLeft > right || nodeBottom < top || nodeTop > bottom);
    });
  }

  function screenToWorld(sx, sy) {
    return { x: (sx - width / 2) / zoom - offsetX, y: (sy - height / 2) / zoom - offsetY };
  }

  function autoZoomAndCenter() {
    if (nodes.length === 0) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    nodes.forEach(node => {
      minX = Math.min(minX, node.x - node.width / 2);
      maxX = Math.max(maxX, node.x + node.width / 2);
      minY = Math.min(minY, node.y - node.height / 2);
      maxY = Math.max(maxY, node.y + node.height / 2);
    });
    const worldWidth = maxX - minX;
    const worldHeight = maxY - minY;
    if (worldWidth === 0 || worldHeight === 0) return;
    zoom = Math.min((width / worldWidth) * 0.7, (height / worldHeight) * 0.7, 2);
    const centerX = minX + worldWidth / 2;
    const centerY = minY + worldHeight / 2;
    offsetX = -centerX;
    offsetY = -centerY;
  }

  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }
  
  window.addEventListener('resize', () => { resizeCanvas(); autoZoomAndCenter(); });

  // --- GESTIONE DEGLI EVENTI UNIFICATA PER MOUSE E TOUCH ---
  function getMouseOrTouchPos(e) {
    if (e.touches && e.touches.length > 0) {
      // Per il touch, restituisce il primo punto di contatto
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else {
      // Per il mouse
      return { x: e.clientX, y: e.clientY };
    }
  }

  function handleInteractionStart(e) {
    hasDragged = false;
    dragStartMouse = getMouseOrTouchPos(e);
    const pos = screenToWorld(dragStartMouse.x, dragStartMouse.y);

    for (let i = nodes.length - 1; i >= 0; i--) {
      const node = nodes[i];
      if (node.isVisible && node.containsPoint(pos.x, pos.y)) {
        isDraggingNode = true;
        dragNode = node;
        dragNode.vx = dragNode.vy = 0;
        dragNode.dragOffsetX = pos.x - node.x;
        dragNode.dragOffsetY = pos.y - node.y;
        canvas.style.cursor = 'grabbing';
        return;
      }
    }
    isPanning = true;
    panStart.x = dragStartMouse.x;
    panStart.y = dragStartMouse.y;
  }

  function handleInteractionMove(e) {
    if (e.touches && e.touches.length === 2) {
      // GESTIONE PINCH-TO-ZOOM (con due dita)
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const newDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);

      if (touchDistance === null) {
        touchDistance = newDistance;
        return; // Inizializza la distanza senza zoom
      }

      const zoomFactor = newDistance / touchDistance;
      const oldZoom = zoom;
      const newZoom = Math.min(Math.max(0.1, oldZoom * zoomFactor), 10);
      
      const centerX = (t1.clientX + t2.clientX) / 2;
      const centerY = (t1.clientY + t2.clientY) / 2;
      const mouseX = centerX - width / 2;
      const mouseY = centerY - height / 2;
      const worldX = (mouseX) / oldZoom - offsetX;
      const worldY = (mouseY) / oldZoom - offsetY;
      offsetX = (mouseX) / newZoom - worldX;
      offsetY = (mouseY) / newZoom - worldY;

      zoom = newZoom;
      touchDistance = newDistance;

    } else {
      // GESTIONE PAN/DRAG (con un dito o mouse)
      const currentPos = getMouseOrTouchPos(e);
      if (!hasDragged && (isPanning || isDraggingNode)) {
        const dx = currentPos.x - dragStartMouse.x;
        const dy = currentPos.y - dragStartMouse.y;
        if (Math.sqrt(dx * dx + dy * dy) > 5) { hasDragged = true; }
      }
      if (isDraggingNode && dragNode) {
        const pos = screenToWorld(currentPos.x, currentPos.y);
        dragNode.x = pos.x - dragNode.dragOffsetX;
        dragNode.y = pos.y - dragNode.dragOffsetY;
        dragNode.vx = dragNode.vy = 0;
      } else if (isPanning) {
        canvas.style.cursor = 'grabbing';
        offsetX += (currentPos.x - panStart.x) / zoom;
        offsetY += (currentPos.y - panStart.y) / zoom;
        panStart.x = currentPos.x;
        panStart.y = currentPos.y;
      }
    }
  }

  function handleInteractionEnd(e) {
    if (isDraggingNode && dragNode && !hasDragged) {
      window.open(dragNode.link, '_self');
    }
    isDraggingNode = false;
    dragNode = null;
    isPanning = false;
    canvas.style.cursor = 'grab';

    // Resetta i dati touch
    if (e.touches && e.touches.length === 0) {
      touchDistance = null;
    }
  }

  function handleWheel(e) {
    e.preventDefault();
    const oldZoom = zoom;
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.min(Math.max(0.1, oldZoom * zoomFactor), 10);
    const mouseX = e.clientX - width / 2;
    const mouseY = e.clientY - height / 2;
    const worldX = (mouseX) / oldZoom - offsetX;
    const worldY = (mouseY) / oldZoom - offsetY;
    offsetX = (mouseX) / newZoom - worldX;
    offsetY = (mouseY) / newZoom - worldY;
    zoom = newZoom;
  }

  // AGGIUNTA DEI LISTENER TOUCH
  canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
  canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
  canvas.addEventListener('touchend', handleInteractionEnd);
  
  // MANTENUTO IL SUPPORTA MOUSE PER DESKTOP
  canvas.addEventListener('mousedown', handleInteractionStart, { passive: false });
  canvas.addEventListener('mousemove', handleInteractionMove, { passive: false });
  canvas.addEventListener('mouseup', handleInteractionEnd);
  canvas.addEventListener('mouseleave', handleInteractionEnd);
  canvas.addEventListener('wheel', handleWheel, { passive: false });

  // Avvia il caricamento
  loadAssetsFromJSON('images.json');
})();
</script>

</body>
</html>