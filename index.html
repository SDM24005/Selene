<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Selene Ulteriormente Ottimizzato</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #000a4b;
    font-family: sans-serif;
    color: white;
    user-select: none;
  }
  #canvas {
    display: block;
    cursor: grab;
    width: 100vw;
    height: 100vh;
  }
  #canvas:active {
    cursor: grabbing;
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let width, height;

  const physics = {
    repulsion: 18000,
    friction: 0.7,
    gravity: 0.025,
    dampening: 0.4,
    repulsionDistanceSq: 300 * 300
  };
  
  // --- IMPOSTAZIONI DI OTTIMIZZAZIONE ---
  const ZOOM_LOD_THRESHOLD = 1.0; // Soglia di zoom per cambiare la qualità dell'immagine
  const VISIBILITY_MARGIN = 300; // Buffer per il culling degli oggetti

  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let nodes = [];
  
  let isPanning = false;
  let panStart = {x:0, y:0};
  let isDraggingNode = false;
  let dragNode = null;
  let hasDragged = false;
  let dragStartMouse = {x:0, y:0};

  let time = 0;
  const imageCache = new Map();

  // --- CLASSE NODE AGGIORNATA PER LOD ---
  class Node {
    constructor(id, link, x, y, maxSize, imageName, imageNameLow) {
      this.id = id;
      this.link = link;
      this.x = x; this.y = y;
      this.vx = 0; this.vy = 0;
      this.maxSize = maxSize || 96;
      this.width = this.height = this.maxSize;
      
      this.imageName = imageName;
      this.imageNameLow = imageNameLow; // Nome dell'immagine a bassa risoluzione

      this.wigglePhaseX = Math.random() * Math.PI * 2;
      this.wigglePhaseY = Math.random() * Math.PI * 2;
      this.wiggleFreqX = 0.0003 + Math.random() * 0.0005;
      this.wiggleFreqY = 0.0003 + Math.random() * 0.0005;

      this.dragOffsetX = 0;
      this.dragOffsetY = 0;
      this.isVisible = false;
      
      this.imgHigh = null;      // Oggetto per immagine HD
      this.imgLow = null;       // Oggetto per immagine LD
      this.imgToDraw = null;    // Immagine da disegnare nel frame corrente
    }
    
    computeSize() {
      const img = this.imgHigh || this.imgLow; // Calcola le dimensioni sull'immagine migliore disponibile
      if (!img || !img.width || !img.height) return;

      if (img.width > img.height) {
          this.width = this.maxSize;
          this.height = img.height * (this.maxSize / img.width);
      } else {
          this.height = this.maxSize;
          this.width = img.width * (this.maxSize / img.height);
      }
    }
    
    containsPoint(px, py) {
      const halfWidth = this.width / 2;
      const halfHeight = this.height / 2;
      return px >= this.x - halfWidth && px <= this.x + halfWidth &&
             py >= this.y - halfHeight && py <= this.y + halfHeight;
    }
    
    applyForce(fx, fy) {
      this.vx += fx;
      this.vy += fy;
    }
    
    update() {
      if (this !== dragNode) {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= physics.friction;
        this.vy *= physics.friction;
      }
    }
  }

  // --- FISICA OTTIMIZZATA ---
  function applyForces() {
    // Ciclo di repulsione ottimizzato: evita di creare un nuovo array con .filter()
    for (let i = 0; i < nodes.length; i++) {
      const nodeA = nodes[i];
      if (!nodeA.isVisible) continue; // Controlla la visibilità qui
      
      for (let j = i + 1; j < nodes.length; j++) {
        const nodeB = nodes[j];
        if (!nodeB.isVisible) continue; // E qui

        const dx = nodeB.x - nodeA.x;
        const dy = nodeB.y - nodeA.y;
        const distanceSq = dx * dx + dy * dy;
        
        if (distanceSq < physics.repulsionDistanceSq && distanceSq > 1) {
          const force = physics.repulsion / distanceSq;
          const angle = Math.atan2(dy, dx);
          const fx = -force * Math.cos(angle);
          const fy = -force * Math.sin(angle);
          nodeA.applyForce(fx * physics.dampening, fy * physics.dampening);
          nodeB.applyForce(-fx * physics.dampening, -fy * physics.dampening);
        }
      }
    }

    // Gravità e 'Wiggle'
    for (const node of nodes) {
      if (!node.isVisible) continue; // Controlla la visibilità anche qui

      const dx = -node.x;
      const dy = -node.y;
      node.applyForce(dx * physics.gravity * physics.dampening, dy * physics.gravity * physics.dampening);
      
      const amplitude = 0.4;
      if (node !== dragNode) {
        const wiggleX = amplitude * Math.sin(time * node.wiggleFreqX + node.wigglePhaseX);
        const wiggleY = amplitude * Math.cos(time * node.wiggleFreqY + node.wigglePhaseY);
        node.applyForce(wiggleX, wiggleY);
      }
    }
    time++;
  }
  
  // --- NUOVA LOGICA DI CARICAMENTO IMMAGINI (LOD) ---
  function manageImageLoading() {
    nodes.forEach(node => {
      if (!node.isVisible) {
        node.imgToDraw = null; // Nulla da disegnare se non visibile
        return;
      }

      const wantsHighRes = zoom > ZOOM_LOD_THRESHOLD;

      if (wantsHighRes) {
        if (node.imgHigh) {
          node.imgToDraw = node.imgHigh;
        } else {
          loadImage(node, 'high');
          node.imgToDraw = node.imgLow; // Fallback su low-res mentre carica
        }
      } else {
        if (node.imgLow) {
          node.imgToDraw = node.imgLow;
        } else {
          loadImage(node, 'low');
          node.imgToDraw = node.imgHigh; // Fallback su high-res se disponibile
        }
      }
    });
  }

  function loadImage(node, quality) {
    const isHigh = quality === 'high';
    const imageName = isHigh ? node.imageName : node.imageNameLow;
    if (!imageName) return;

    if ((isHigh && node.imgHigh) || (!isHigh && node.imgLow)) return; // Già caricata
    
    let cachedImg = imageCache.get(imageName);
    if (cachedImg) {
      if (cachedImg.complete) {
        if (isHigh) { node.imgHigh = cachedImg; node.computeSize(); }
        else { node.imgLow = cachedImg; }
      }
      return;
    }

    const img = new Image();
    img.src = 'img/' + imageName;
    imageCache.set(imageName, img); // Metti in cache per evitare richieste multiple

    img.onload = () => {
      if (isHigh) {
        node.imgHigh = img;
        node.computeSize();
      } else {
        node.imgLow = img;
      }
    };
    img.onerror = () => console.warn('Immagine non trovata:', img.src);
  }

  // --- FUNZIONI PRINCIPALI E DI UTILITY ---
  function loadAssetsFromJSON(url) {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!Array.isArray(data)) return console.error('JSON non è un array');
        
        const gridSpacing = 160;
        const gridCols = Math.ceil(Math.sqrt(data.length));

        data.forEach((item, i) => {
          const col = i % gridCols;
          const row = Math.floor(i / gridCols);
          const x = col * gridSpacing - (gridCols * gridSpacing) / 2;
          const y = row * gridSpacing - (gridCols * gridSpacing) / 2;
          // Passa entrambi i nomi delle immagini al costruttore
          const node = new Node(i, item.link, x, y, 96, item.name, item.name_low);
          nodes.push(node);
        });

        setupAndStart();
      })
      .catch(err => console.error('Errore caricamento JSON:', err));
  }

  function setupAndStart() {
    resizeCanvas();
    autoZoomAndCenter();
    animate();
  }

  // --- FUNZIONE DRAW AGGIORNATA ---
  function draw() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#000a4b';
    ctx.fillRect(0, 0, width, height);

    ctx.translate(width / 2, height / 2);
    ctx.scale(zoom, zoom);
    ctx.translate(offsetX, offsetY);

    updateVisibility();
    manageImageLoading(); // Chiama la nuova funzione di gestione immagini

    for (const node of nodes) {
      if (!node.isVisible || !node.imgToDraw) continue;

      // La vecchia logica di 'scale' non è più necessaria
      const drawWidth = node.width;
      const drawHeight = node.height;
      ctx.drawImage(node.imgToDraw, node.x - drawWidth / 2, node.y - drawHeight / 2, drawWidth, drawHeight);
    }
  }

  function animate() {
    applyForces();
    for (const node of nodes) {
      node.update();
    }
    draw();
    requestAnimationFrame(animate);
  }

  function updateVisibility() {
    const left = -offsetX - width / 2 / zoom - VISIBILITY_MARGIN;
    const right = -offsetX + width / 2 / zoom + VISIBILITY_MARGIN;
    const top = -offsetY - height / 2 / zoom - VISIBILITY_MARGIN;
    const bottom = -offsetY + height / 2 / zoom + VISIBILITY_MARGIN;

    nodes.forEach(node => {
      const nodeLeft = node.x - node.width / 2;
      const nodeRight = node.x + node.width / 2;
      const nodeTop = node.y - node.height / 2;
      const nodeBottom = node.y + node.height / 2;
      node.isVisible = !(nodeRight < left || nodeLeft > right || nodeBottom < top || nodeTop > bottom);
    });
  }

  function screenToWorld(sx, sy) {
    return { x: (sx - width / 2) / zoom - offsetX, y: (sy - height / 2) / zoom - offsetY };
  }

  function autoZoomAndCenter() {
    if (nodes.length === 0) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    nodes.forEach(node => {
      minX = Math.min(minX, node.x - node.width / 2);
      maxX = Math.max(maxX, node.x + node.width / 2);
      minY = Math.min(minY, node.y - node.height / 2);
      maxY = Math.max(maxY, node.y + node.height / 2);
    });
    const worldWidth = maxX - minX;
    const worldHeight = maxY - minY;
    if (worldWidth === 0 || worldHeight === 0) return;
    zoom = Math.min((width / worldWidth) * 0.7, (height / worldHeight) * 0.7, 2);
    const centerX = minX + worldWidth / 2;
    const centerY = minY + worldHeight / 2;
    offsetX = -centerX;
    offsetY = -centerY;
  }

  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }
  
  // --- GESTIONE EVENTI (INVARIATA) ---
  window.addEventListener('resize', () => { resizeCanvas(); autoZoomAndCenter(); });

  canvas.addEventListener('mousedown', e => {
    hasDragged = false;
    dragStartMouse = { x: e.clientX, y: e.clientY };
    const pos = screenToWorld(e.clientX, e.clientY);

    for (let i = nodes.length - 1; i >= 0; i--) {
      const node = nodes[i];
      if (node.isVisible && node.containsPoint(pos.x, pos.y)) {
        isDraggingNode = true;
        dragNode = node;
        dragNode.vx = dragNode.vy = 0;
        dragNode.dragOffsetX = pos.x - node.x;
        dragNode.dragOffsetY = pos.y - node.y;
        canvas.style.cursor = 'grabbing';
        return;
      }
    }
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
  });

  canvas.addEventListener('mousemove', e => {
    if (!hasDragged && (isPanning || isDraggingNode)) {
      const dx = e.clientX - dragStartMouse.x;
      const dy = e.clientY - dragStartMouse.y;
      if (Math.sqrt(dx * dx + dy * dy) > 5) { hasDragged = true; }
    }
    if (isDraggingNode && dragNode) {
      const pos = screenToWorld(e.clientX, e.clientY);
      dragNode.x = pos.x - dragNode.dragOffsetX;
      dragNode.y = pos.y - dragNode.dragOffsetY;
      dragNode.vx = dragNode.vy = 0;
    } else if (isPanning) {
      canvas.style.cursor = 'grabbing';
      offsetX += (e.clientX - panStart.x) / zoom;
      offsetY += (e.clientY - panStart.y) / zoom;
      panStart.x = e.clientX;
      panStart.y = e.clientY;
    }
  });

  function releaseInteraction() {
    if (isDraggingNode && dragNode && !hasDragged) {
      window.open(dragNode.link, '_self');
    }
    isDraggingNode = false;
    dragNode = null;
    isPanning = false;
    canvas.style.cursor = 'grab';
  }

  canvas.addEventListener('mouseup', releaseInteraction);
  canvas.addEventListener('mouseleave', () => {
    isDraggingNode = false; dragNode = null; isPanning = false; canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const oldZoom = zoom;
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.min(Math.max(0.1, oldZoom * zoomFactor), 10);
    const mouseX = e.clientX - width / 2;
    const mouseY = e.clientY - height / 2;
    const worldX = (mouseX) / oldZoom - offsetX;
    const worldY = (mouseY) / oldZoom - offsetY;
    offsetX = (mouseX) / newZoom - worldX;
    offsetY = (mouseY) / newZoom - worldY;
    zoom = newZoom;
  }, { passive: false });

  // Avvia il caricamento
  loadAssetsFromJSON('images.json');

})();
</script>

</body>
</html>